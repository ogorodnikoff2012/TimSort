\documentclass[notitlepage]{article}
\usepackage{xenonpreamble}
\title{TimSort}
\author{Владимир Огородников}
\begin{document}
\maketitle
\section{Постановка задачи}
Требуется отсортировать массив произвольных данных длины $n$ за время $O(n\log n)$.
\section{Алгоритм}
\subsection{Описание алгоритма}
Разобъём массив на последовательные блоки так, чтобы в каждом из них элементы были
расположены в строго убывающем либо нестрого возрастающем порядке, и при этом длина
каждого блока была не меньше, чем $f(n) \leq C$ (см. реализацию в следующем разделе).
Для этого воспользуемся жадным алгоритмом: предположим, что первые $k$ элементов
массива уже разделены на блоки. Объединим следующие $min(f(n), n - k)$ элементов в блок.
Если они уже упорядочены, продолжим добавлять элементы так, чтобы заданная монотонность
сохранялась, после чего развернём блок так, если элементы в нём убывают. В противном
случае воспользуемся любой сортировкой, например, \texttt{insertionSort()}. 

Заведём список блоков и добавим в него {\it сверхжирный}, {\it жирный} и все нормальные
блоки в естественном порядке. Сверхжирным блоком будем называть фиктивный блок длины
$2n + 2$, жирным -- $n + 1$. Сольём некоторые блоки так, чтобы для любых двух
последовательных блоков длиной $Y$ и $Z$ выполнялось $Y > Z$ (свойство 1), а для любых
трёх $X$, $Y$ и $Z$ выполнялось $X > Y + Z$ (свойство 2). Заметим, что для первой тройки
и для первых двух двоек эти свойства выполнены всегда вне зависимости от размера первого
блока. Будем рассматривать блоки слева направо, начиная с четвёртого (с индексом 3 в 
0-индексации). Если для него и предыдущего нарушено свойство 1, сольём его с предыдущим
с помощью \texttt{inplaceMerge()}, после чего рекурсивно запустимся от соответствующего
элемента списка. Если для него и двух предыдущих нарушено свойство 2, сольём два
предыдущих блока, после чего рекурсивно запустимся от результата слияния, после чего
рекурсивно запустимся от исходно рассматриваемого блока. Если оба свойства выполнены,
перейдём к следующему блоку.

Теперь начнём сливать получившиеся блоки с конца списка. Когда в списке останется 1
нормальный блок (и 2 фиктивных), массив окажется отсортированным. Конец алгоритма.

\subsection{Код на C++}
{\em Данная версия кода может быть устаревшей. Последнюю версию можно найти на
    \url{https://github.com/ogorodnikoff2012/TimSort}.}
\inputminted[linenos]{c++}{include/timsort.h}

\subsection{Оценка времени работы}
На первом этапе каждый блок обрабатывается либо за некоторое время, не превосходящее
$minRun^2(n) \leq C_1$ (время, необходимое для квадратичной сортировки), либо за
$C_2*k$, где $k$ -- длина блока, $C_2$ -- время, необходимое для просмотра
соответствующих элементов и, возможно, разворачивания массива. Значит, каждый блок
набирается за $Ck$ времени. Значит, весь первый этап проходит за $Cn \in O(n)$.

Для оценки времени работы второго этапа воспользуемся методом предоплаты. Пусть на
каждый блок в тот момент, когда он впервые начинает рассматриваться, кладётся $2lh$
монеток, где $l$ -- длина блока, $h$ -- количество блоков перед ним. Пусть также
сливание двух блоков в один стоит столько монеток, сколько элементов в сумме в этих
двух блоках. 

Рассмотрим случаи, когда мы сливаем два блока на втором этапе. 

\begin{tabular}{|c|c|c|c|c}
    \hline
    \dots & X & Y & Z & \\
    \hline
\end{tabular}

Если нарушено правило 1, то есть $Z \geq Y$, то мы сольём $Y$ и $Z$. При этом мы
потратим $Y + Z$ монеток. Из списка мы можем взять $2hY + 2(h + 1)Z - 2h(Y + Z) = 2Z
\geq Z + Y$ монеток. После этого мы рекурсивно запустимся. Значит, в этом случае всё
корректно.

Если нарушено правило 2, то есть $Z + Y \geq X$, то мы сольём $X$ и $Y$. При этом
правило 1 нарушено не было, то есть $Y > Z$. Нам нужно $X + Y$ монеток, мы можем
получить $2hX + 2(h + 1)Y + 2(h + 2)Z - 2h(X + Y) - 2(h + 1)Z = 2Y + 2Z > Y + (Y + Z)
\geq Y + X$ монеток. После этого мы рекурсивно запустимся дважды. Значит, и в этом
случае всё корректно.

Докажем, что всего мы положим не больше, чем $Cn\log_2n$ монеток. Назовём список
{\it правильным}, если оба свойства в нём выполнены. Тогда $2Z < Z + Y < X$. Значит,
если первый блок в списке имеет длину $k$, то список имеет длину не больше, чем
$2\log_2k + 1$. Перед тем, как добавить очередной блок в список, список правильный.
Значит, на этот блок мы кладём не больше, чем $Ck\log_2n$ монеток. Значит, всего
монеток не больше, чем $Cn\log_2n$. Следовательно, второй этап проходит за $O(n\log n)$.

В третьем этапе мы сливаем не больше, чем $C_1\log_2n$ блоков суммарной длиной $n$.
Значит, все слияния мы выполняем не дольше, чем за $Cn\log_2n \in O(n\log n)$ действий.

Таким образом, алгоритм TimSort работает за $O(n\log n)$, что и требовалось доказать.

\end{document}
